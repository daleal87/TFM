#include "vision/platform_detection/platform_detection_real.hpp"

Platform_Detection::Platform_Detection() {
    ROS_INFO("Init Class: Platform_Detection");
    
    ros::NodeHandle nh_;
    
    //TOPICS
    std::string platform_position_topic_;
    std::string camera_info_topic_;
    std::string ardrone_navdata_topic_;
    std::string imu_topic_;
    
    // GETTING ROS PARAMETERS
    nh_.param("cam_info_topic", camera_info_topic_, std::string("/ardrone/bottom/camera_info"));
    nh_.param("platform_position_topic", platform_position_topic_, std::string("/platform/estimated_position"));
    nh_.param("ardrone_navdata_topic", ardrone_navdata_topic_, std::string("/ardrone/navdata"));
    nh_.param("imu_topic", imu_topic_, std::string("/ardrone/imu"));


    //We publish on the platform_POSITION_TOPIC 
    platform_position_pub_ = nh_.advertise<geometry_msgs::PoseStamped>(platform_position_topic_, 1);

    //We subscribe to the CAMERA_INFO_TOPIC of the quadrotor
    cam_info_subs_ = nh_.subscribe(camera_info_topic_, 1, &Platform_Detection::cam_info, this);

    //We subscribe to the NAVDATA_TOPIC of the ardrone
    navdata_subs_ = nh_.subscribe(ardrone_navdata_topic_, 1, &Platform_Detection::nav_callback, this);
    
    //We subscribe to the IMU_TOPIC of the quadrotor
    imu_info_subs_ = nh_.subscribe(imu_topic_, 1, &Platform_Detection::angle, this);

    //TIMER
    timer = nh_.createTimer(ros::Duration(0.02), &Platform_Detection::timerCallback, this);


    // ----------------------------- SERVICES --------------------------------- //
    //Ask for services
    client_1 = nh_.serviceClient<std_srvs::Empty>("ardrone/togglecam");
    client_2 = nh_.serviceClient<std_srvs::Empty>("ardrone/flattrim");

    std_srvs::Empty::Request req;
    std_srvs::Empty::Response resp;

    // CAMERA TOGGLE
    bool success = client_1.call(req,resp);
    if (success) 
        ROS_INFO_STREAM("Camera succesfully toggled");
    else 
        ROS_INFO_STREAM("Error while trying to toggle camera");
    

    // VARIABLES' INITIALIZATION
    cam_width_degree  = 92*DEG2RAD;
    cam_height_degree = 52*DEG2RAD; //cam_width_degree*(cam_height/cam_width) //NOT MEASURED

    ROS_INFO("Setup completed");
}
   
void Platform_Detection::nav_callback(const ardrone_autonomy::NavdataConstPtr& nav_msg_in) {
    tags_count = nav_msg_in->tags_count;
    time_stamp = nav_msg_in->tm;   
        
    for (uint32_t i=0; i < tags_count; i++) {
        tags_distance[i] = nav_msg_in->tags_distance[i];
        tags_xc[i] = nav_msg_in->tags_xc[i];
        tags_yc[i] = nav_msg_in->tags_yc[i];
        tags_width[i] = nav_msg_in->tags_width[i];
        tags_height[i] = nav_msg_in->tags_height[i];
        tags_orientation[i] = nav_msg_in->tags_orientation[i];
    }
}

void Platform_Detection::angle(const sensor_msgs::ImuConstPtr& ardrone_imu) {
    angle_x               = ardrone_imu->orientation.x;
    angular_velocity_x    = ardrone_imu->angular_velocity.x;
 
    angle_y               = ardrone_imu->orientation.y;
    angular_velocity_y    = ardrone_imu->angular_velocity.y;
 
    linear_acceleration_x = ardrone_imu->linear_acceleration.x;
    linear_acceleration_y = ardrone_imu->linear_acceleration.y;
}

void Platform_Detection::cam_info(const sensor_msgs::CameraInfo& cam_parameters) {
    //ROS_INFO("Parameters from the pinhole model");
    fx = cam_parameters.K.at(0);
    fy = cam_parameters.K.at(4);
    cx = cam_parameters.K.at(2);
    cy = cam_parameters.K.at(5);
    T  = cam_parameters.K.at(1);
}

void Platform_Detection::timerCallback(const ros::TimerEvent& e) {
    // int tag_id =0;
    // vision_angle[X] = ( (((float)(tags_xc[tag_id]-500.0)) /500.0) *cam_width_degree/2.0);
    // vision_angle[Y] = ( (((float)(tags_yc[tag_id]-500.0)) /500.0) *cam_height_degree/2.0);
    // tag_position[X] = tags_distance[tag_id]*sin(vision_angle[X]);
    // tag_position[Y] = tags_distance[tag_id]*sin(vision_angle[Y]);
    // tag_position[Z] = tag_position[X]/tan(vision_angle[X]);

    // geometry_msgs::PoseStamped centroid;
    //     centroid.header.stamp = ros::Time::now();
    //     centroid.header.seq = ros::Time::now().toSec();
    //     centroid.header.frame_id = "/ardrone/ardrone_base_bottomcam";
    //     centroid.pose.orientation.w=1;
    //     centroid.pose.orientation.x=0;
    //     centroid.pose.orientation.y=0;
    //     centroid.pose.orientation.z=0;
    //     centroid.pose.position.x = tag_position[X];
    //     centroid.pose.position.y = tag_position[Y];            
    //     centroid.pose.position.z = tag_position[Z];          
    
    // ROS_INFO("La posicion del objetivo es: (%f , %f, %f) en metros respecto a la camara", centroid.pose.position.x, centroid.pose.position.y, centroid.pose.position.z);

    // platform_position_pub_.publish(centroid);
    
    // ROS_INFO("count: %i, xc: %i, yc: %i, distance: %f", tags_count , tags_xc[tag_id] , tags_yc[tag_id] , tags_distance[tag_id]); 
    // //width: %i, height: %i, orientation: %i
}

int main(int argc, char** argv)
{
    ros::init(argc, argv, "platform_detection_real");
    
    Platform_Detection platform_detection;
    ros::spin();
    ROS_INFO("platform_detection::main.cpp::No error.");
    return 0;
}